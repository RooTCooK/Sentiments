# 蓝桥杯-最大的最小公倍数

## 概述

> 已知一个正整数N，问从1~N中任选出三个数，他们的最小公倍数最大可以为多少。

## 总结

>+ 在刚开始觉得自己写不了，参考网上的思路之后解答完毕，蓝桥系统没有AC，但是答案是对的，之后用简单的测试之后，我认为蓝桥的评测系统出现问题，无法判断正确与否。  
>
>+ 还是需要记住一些常用的头文件，虽然现在一直在使用 bits/stdc++.h ，但是还是需要及注意些的，今天(2020年5月5日15:20:13)自己凭借语音打出的algorithm，是对的，觉得很神奇，读音就可以帮助记忆，总之需要多记一点了。  

## 思路

> 思路时参考网上的解答思路，自己思索之后确实是的，刚开始可能被算法的入门题目整蒙了，只要自己仔细思索，问题还是可以解决的  
> 1、第一想法
刚开始看到这个题目的时候第一想法就是枚举1~N中任意三个数,然后求它们的最小公倍数,从这些最小公倍数中再选择最大的一个即为正确答案,可是1<=N<=10^6,如果要枚举任意三个数,最简单的做法就是三个嵌套的for循环,这样的话时间复杂度为O(N^3),会运行超时的。  
2、正确解答  
数学知识:如果三个数互为质数,那么这三个数的乘积便为它们的最小公倍数。  
> 因为本题目中要求最小公倍数的最大值,那么可以直接从N向前看,找三个连续的互为质数的数,那么它们的乘积便是1~N最小公倍数的最大值。
有以下二种情况。  
(1)、当N为奇数时,那么N,N-1,N-2互为质数,很明显N*N-1*N-2是1~N最小公倍数的最大值。  
(2)、当N为偶数时,且能被3整除时,N-1,N-2,N-3互质,此时N-1*N-2*N-3是1~N最小公倍数的最大值；当N为偶数时,但不能被3整除时,N,N-1,N-3互质,此时N*N-1*N-3是1~N最小公倍数的最大值。  

## 代码

```C++
include<bits/stdc++.h>
using namespace std;

long long maxGcd(long long n){
	if(n<=2){
		return n;
	}else if(n%2){
		return n*(n-1)*(n-2);
	}else{
		if(!(n%3))
			return (n-1)*(n-2)*(n-3);
		else 
			return n*(n-1)*(n-3);
	}
}

long long gcd(long long a,long long b){
	if(a<b) 
		swap(a,b);
	return b==0? a:gcd(b,a%b);
}

int main(){
	long long n= 0;
	cin >> n;
	cout << maxGcd(n);
	return 0;
}
```
