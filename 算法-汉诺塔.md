# 算法练习之汉诺塔

## 题目大意

> 法国数学家爱德华·卢卡斯曾编写过一个印度的古老传说：在世界中心贝拿勒斯（在印度北部）的圣庙里，一块黄铜板上插着三根宝石针。印度教的主神梵天在创造世界的时候，在其中一根针上从下到上地穿好了由大到小的64片金片，这就是所谓的汉诺塔。不论白天黑夜，总有一个僧侣在按照下面的法则移动这些金片：一次只移动一片，不管在哪根针上，小片必须在大片上面。僧侣们预言，当所有的金片都从梵天穿好的那根针上移到另外一根针上时，世界就将在一声霹雳中消灭，而梵塔、庙宇和众生也都将同归于尽。  

## 分析

>&emsp;&emsp; 汉诺塔问题，我先从2个，到3个进行模拟，始终推不到n层塔上面，比较烦，从底层想上思考出解决方案，在现在看来是逆向求解递归，实属不易。  
>&emsp;&emsp; 相反的，从总体上去思考汉诺塔问题，就很容易把握整体，但是细微之处仍然会比较模糊，就像从底层推导到n层，无法地推一样。  
> 综上，缺乏抽象处理问题的能力，无法将问题凝练的转化。正如从特例推广到通解，难以将已有的特例抽象出来，以本次汉诺塔问题为例，我知道3层的时候，先把第一个挪到中间，再把第二个挪到右边，这样就可以先把前两个挪到最右边，然后在挪第三个，这个时候吐过能否思考出3层要先处理前两层然后在处理第三层，处理第三层时，可以把前两个当做一个整体进行处理(这个时候，就会归并到递归了，因为两个的已经有了处理的方案)，当然第三个如果按照个例也是可以处理好。  
>&emsp;&emsp; 当处理到第四层时，就比较吃力了，脑子里想不出解决方案了，因为我都是用的个例去解决的这个问题，并没有归结处理的策略，比如2层时，从初始位置from，到目标位置to，中间还有一个暂存位置mid，于是能够归结起来，开始位置，目标位置，暂存位置，然后再把n层抽象为n-1和第n层的两部分，每次都递归调用处理n-1层，这样就可以不断的在递归中构造出整体整体框架。因而算法就会变得很简单。  
>&emsp;&emsp; 总之，递归问题，一定要找出架构，出口，下一个的递归入口，整体与部分，层层分离，又相互联系。

## 代码

```C++
#include<bits/stdc++.h>
using namespace std;
void hanoi(int n,char from,char to,char mid){
    if(n == 1){
        printf("from %c to %c \n",from,to);
    }else{
        hanoi(n-1,from,mid,to);
        printf("from %c to %c \n",from,to);
        hanoi(n-1,mid,to,from);
    }
}
int main(){
    int n = 10;
    hanoi(n,'A','C','B');
    return 0;
}
```  
