# 关于使用又拍云的总结

## 使用过程，感想

>&emsp; 现在(2020年5月14日06:52:24)才开始总结使用又拍云的经历，因为之前还是没有养成总结经验的习惯，直到前几天，我有需要使用又拍云时，才发现自己已经忘掉怎么用又拍云的使用流程了。  
>&emsp; 又拍云的存储服务，是使用个人网站页面底下打上又拍云的连接作为广告而提供的67元的消费券，为期一年，下年需要再次提交审核才可以再次获得消费券，基本上提交审核时间为：8-15，此外新用户也是有为期一个月的31元消费券，我没用玩，真的亏了  
>&emsp; 只用之后，对又拍云的认证机制有一些了解，他使用操作员和密码MD5值进行权限验证，上传和签名分离，上传在客户端执行，计算签名在做服务器执行，所以签名计算时使用了文件参数信息，这些参数之后还会上传到又拍云服务器，这就消除了，如果有人篡改文件签名会和又拍云根据计算出来的signature不一致，从而确保使用者的身份权利，同时也保证了上传信息的一致性，正确性。  
>&emsp; 在进行开发时，还是要多找官方文档，还有官方做的API示例，这样可以少走很多弯路，毕竟拿来主义。直接拿来用既不用自己操心细碎的点，也可以准确快速的完成目标。还有官方会公布一下预言的API这些还是很好的，如果没有自己需要的语言的话，还可以参考已知语言进行仿写，最终得到自己使用语言的使用程序。

## 认证权鉴 的官方推荐流程(也是我摸爬滚打之后使用的，很方便)

```解释
            +-----------------+ +-----------------+ +-----------------+
            | Client/Browser  | |    FORM API     | | Customer Server |
            +-----------------+ +-----------------+ +-----------------+
                    |                   |                   |
                    |                   |                   |
                   +++        Request authorization        +++
                   |-|====================================>|-|
                   |-|                  |                  |-|
                   |-|                  |                  |-|
                   |-|        Response authorization       |-|
                   |-|<====================================|-|
                   +++                  |                  +++
                    |                   |                   |
                    |                   |                   |
                    |                   |                   |
                   +++     Upload      +++                 +++
                   |-|================>|-|     Notify      |-|
                   |-|                 |-|---------------->|-|
                   |-|                 |-|                 |-|
                   |-|     Response    |-|                 |-|
                   |-|<================|-|                 |-|
                   +++                 +++                 +++
                    |                   |                   |
                    |                   |                   |  
```

## 使用流程

>&emsp; 首先需要获得 认证鉴权 在进行上传，在又拍云官方文档中，[使用介绍](https://docs.upyun.com/api/authorization/#header)中，提供了两种基本方式，1.把参数放在HTTP Header中，2.把参数放在HTTP Body中，最终两种方式所提交的参数格式，内容基本一致，一些具体参数如下：  

|参数|必选|说明|
|:-----:|:-----:|:-----:|
|Operator|是|服务的操作员名称|
|Method|是|请求方式，如：GET、POST、PUT、HEAD 等|
|URI|是|请求路径|
|Date|是|请求日期时间，GMT 格式字符串 (RFC 1123)，如 Wed, 29 Oct 2014 02:26:58 GMT|
|Policy|是|上传参数的 Base64 编码，详见 Policy 算法|
|Content-MD5|否|请求体的 MD5 值，如果文件太大计算 MD5 不方便或请求体为空，可以为空|
|Password|是|服务的操作员密码的 MD5 值|

```解释
认证参数Authorization: UPYUN <Operator>:<Signature>  
<Signature> = Base64 (HMAC-SHA1 (<Password>,<Method>&<URI>&<Date>&<Content-MD5>))  
在微信小程序中，我使用的获得authorization策略是，微信小程序计算<Method>&<URI>&<Date>&<Content-MD5>的值，然后传到服务器，使用我的password进行sha1的编码，然后返回给小程序，小程序拿到了authorization在上传到又拍云服务器。这样子我的password不必下发到小程序，同时还能减少计算量，服务器仅需要计算sha1的工作量。  
```

>&emsp; 而放在body中时，仅仅比放在header中多加了一个参数Policy,其中 上传参数 如下

```解释
Policy 算法
生成步骤：
1.将上传参数键值对转换为 JSON 字符串；
2.将第 1 步所得到的字符串进行 Base64 Encode 处理，得到 policy。
上传参数为(这些参数均是必要的上传参数，在微信小程序中，引用官方的api然后初始化又拍云连接就是要传入这些，然后实例化又拍云的类，之后只要用这个实例就可以调用upload函数直接上传，其中signature的获取就需要我的服务器计算authorization)
bucket      是  文件上传到的服务
save-key    是  文件保存路径，可用占位符，见 路径设置
expiration  是  请求的过期时间，UNIX UTC 时间戳，单位秒。建议设为 30 分钟
```
